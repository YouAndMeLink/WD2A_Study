# 2022.04.26 자바 수업 정리

컴퓨터

- 하드웨어/소프트웨어

\1. 하드웨어

1. CPU(중앙처리장치)

1. 제어장치 - Control

2. 연산장치 - 연산기

- 몇 개에 있는 지에 따라 코어 갯수도 달라짐(2, 4, 8, 16..)

- 코어가 8개면 동시에 8개 연산 가능

⇒ 위의 두 가지가 대표적인 장치

2. 기억장치

1. 주기억장치 - Memory, RAM+ROM 등

필요한 이유 : CPU의 용량이 작기 때문, 처리해야 할 데이터가 어디에 존재해야지 처리할 수 있기 때문에, 그것을 주기억/보조 에 놔둘지는 추후에 결정!

2. 보조기억장치 - 하드디스크, SSD 등

3. 입출력장치

1. 입력

2. 출력

기본으로 구성돼서 하드웨어가 운영이 됨

\1. 소프트웨어

1. 시스템 - OS(운영체제)

2. 응용

전원을 켠 순간에 컴퓨터에 하드웨어의 기본요소들이 정상인지 확인해야함

하드웨어를 체크하는 순간 ⇒ 부팅

하드웨어 자체가 문제가 있으면 OS 단계에 넘어가지 못함

전원을 킨 후 CPU, RAM, 모니터, 키보드 등 정상인 것을 확인하고 하드웨어 운영을 위해 운영체제가 컴퓨터에 사용될 수 있는 지 확인, 이것은 하드디스크에 운영체제에 있음

운영체제는 하드디스크 어느 영역에 있다고 정해져 있음 그영역으로 가서 파일을 읽어서 메모리에 올리는 순간 올라간 파일이 기억장치에 올라감, 그 파일이 동작하기 위해 컨트롤은 CPU가 한다

CPU가 해당되는 내용을 읽어서 역할을 처리하면서 수행됨, 이 과정이 OS가 부팅되는 순간이 지나감

시간이 지나면서 로그인 화면이 뜨고 등등 → 하드디스크가 기억장치에 올라가면서 돌아감?

로그인 화면이 뜬다? ⇒ RAM(8G)라는 영역 중에 상당 부분을 윈도우OS가 부팅과정을 거쳐서 차지하고 있음

꺼져 있을 때는 메모리에 아무것도 없음 그것은 보조기억장치(USB, SSD, HDD)에 존재

부팅을 거치게 되면 주기억장치(RAM)에 올려놓게 된다

OS가 RAM에 올라가고 과제하려고 HWP 실행 → HWP는 보조기억장치에 들어있음(메모리에 처음부터 있지 않음) 더블클릭 하는 순간 실행 파일이 수행되면 필요한 파일들이 주기억장치에 올라가게 된다. 수행 필요한 파일들이 있을 때 메모리에 적재 ⇒ 동시에 음악을 듣고 싶어서 mp3 수행하게 되면 파일은 보조기억장치에 있지만 수행되는 순간 주기억장치에 적재된다.

메모리 공간이 꽉차게 되었을 때는?

OS가 스케쥴링을 한다! 연속되어 있는 큐라는 공간에다가 프로세서들을 집어넣고 어떤 놈을 수행할지 컨트롤한다. 컨트롤하면서 메모리에 올라 왔던 놈 중에 오래전에 실행된 것들을 내리고 등등 이러한 최적의 방법들이 있다. 그러다가 여러가지 스케쥴링 알고리즘이 탄생하게 되었다.

메모리, 스케쥴링, 하드디스크 관리 ⇒ OS(=커널)

커널을 만들었다 리눅스라는 코어를 통해 메모리 관리, CPU 관리, 처리 이 모든 것들을 수행할 수 있는 코어를 탄생하게 되엇다

필요한 여러가지 명령(ls, mkdir, )어 들을 쉘이라고 한다.

쉘을 코어 커널에 해당되는 것들은 핵심적인 것을 공유한다.

윈도우 OS에 커널이 있는데, 외부 공개하지 않음

커널이 어떠한 형태로 만들어져 있는 지 공개하지 않음

리눅스 같은 경우 커널 자체도 아예 오픈되어있다.

메모리

CPU안에 레지스터가 있다. 굉장히 빠른 고가임

연산장치, 제어장치가 구성된 것이 CPU 인데

CPU에 데이터를 계산하려고 하면 데이터가 CPU로 전달해야 한다. 10 + 20 = 30

10 20라는 값이 전달되어 질 때 전달되어지기위한 기억장치⇒ CPU 내부에 존재하는 레지스터

여러가지 레지스터들이 존재한다.

아주 고속, 고가 메모리 ⇒ 레지스터

레지스터의 크기를 늘릴 수 가 없다 ⇒ CPU도 비싸짐

그 때문에 레지스터 + 캐쉬 형태로 만들어짐 ⇒ CPU로 구성

[예시]

for문 천번 돌릴 때 ⇒ SUM에 누적으로 더함

```jsx

for(int i = 0; i < 1000; i++) {

sum += i;

}

```

결과적으로 이러한 처리를 컴퓨터의 CPU의 연산장치가 한다!

처리되는 과정을 깊숙히 보면

CPU한테 신호를 전달 ⇒ 천번의 반복문 실행 ⇒ 필요한 변수는 i, sum ⇒ 이 변수는 RAM에 존재 ⇒ 결과적으로 천번을 수행되는 동안 속도가 느려짐 ⇒ 레지스터의 값들과 캐쉬 메모리의 값들을 CPU내부에 빨리 처리해서 최종 결과를 반환

RAM과 레지스터 사이에서 좀 더 빨리 처리 ⇒ 캐쉬(용량의 크기에 따라 CPU 성능도 달라짐)

주기억장치(RAM) + ROM + HDD ⇒ 메모리

HDD → 프로그램 코드들을 메모리(주기억장치) 적재 ⇒ RAM의 용량이 부족할 때 HDD에 옮기는 데 이것을 가상기억장치라고 한다. 대신 속도가 느려짐(하드디스크에 계속해서 이동해야 되기 때문에 이것에 대한 조치는 RAM 메모리 용량을 늘려야함)

---

# 2교시

프로그램 언어의 목표 ⇒ 내가 원하는 무언가를 컴퓨터에 명령을 내리는 것

컴퓨터가 제일 좋아하는 언어 ⇒ 기계어

기계어를 대안으로 나온 것 ⇒ 어셈블리어

어셈블리어는 10110110(이진수) 를 ADD, LOAD, SAVE 와 같은 형태로 변환

ADD X, Y ⇒ X + Y ⇒ 1011010101..

영어단어를 기계어에 1:1로 대입하여 영어로 표기한 것 ⇒ 어셈블리어

속도가 엄청 빨라짐

하드웨어를 직접적으로 컨트롤 ⇒ 어셈블리어(최근에는 사용 빈도 수가 낮음)

[예시]

ROAD A, 0

ROAD SUM, 0

SET JMP

ADD SUM, A

ADD A, 1

JUMP JMP

⇒ 반복문과 같은 형태, 한 스택씩 명령을 내리는 것 : 어셈블리어

이것을 0과 1로 변환한 것이 기계어!

기계어로 만들면 운영체제가 똑같이 쓸 수 있냐? 아님!

운영체제마다 기계어가 다르다? 기계어라는 것은 위와 같은 패턴으로 변환

윈도우 OS에 맞는 패턴, 리눅스에 맞는 패턴

컴파일 했을 때 .exe 라는 실행 파일 생성 ⇒ 만들어진 실행파일이 결국에는 동작하는 것을 기계어로 만들어진것 ⇒ 윈도우즈에서 실행된 파일을 리눅스에서는 실행되지 않음 해당되는 소스코드를 가지고 다시 리눅스에 맞게 컴파일을 실행한다.(자바하고 C언어의 가장 큰 차이점, C언어는 소스코드를 기계어로 변환, 소스코드를 옮겨놓고 다시 컴파일! 자바는 JVM을 통해서 바이드코드를 공유하며 실행한다.)

## 진법

### 10진법

숫자를 표현하는데 있어서 기호를 10개 사용, 십진법사용하는 기호는 0부터 9까지 총 10개

이것을 가지고 모든 숫자를 표현할 수 있다.

245 라는 기호를 통해 십진법 숫자를 표현, 위치마다 자리 값이 있다. 마지막에 있는 자리값이 10의 0승, 1* 5

10의 1승 ⇒ 4 * 10

10의 2승 ⇒ 2 * 100

200 + 40 + 5 ⇒ 245

### 2진법

0과 1로 표현,

1101

2의 0승 ⇒ 1의 자리

2의 1승 ⇒ 2의 자리

2의 2승 ⇒ 4

2의 3승 ⇒ 8

...

8 + 4 + 1 => 13

### 8진법

기호 8개로 표현, 0~7까지

142라는 숫자가 있다고 가정하자.

8의 0승 ⇒ 1

8의 1승 ⇒ 8

8의 2승 ⇒ 64

십진수 : 64 + 32 + 2 ⇒ 98

### 16진법

기호 16개, 0~9 \ ABCDEF

A = 10

B = 11

c = 12

...

### 32진법

기호 32개, A-Z

### 64진법

기호 64개, 알파벳 대/소문자, @, !...
